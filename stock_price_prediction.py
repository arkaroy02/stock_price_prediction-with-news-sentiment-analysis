# -*- coding: utf-8 -*-
"""stock price prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ostP6T0WnUnufAUTDDCQzU3_VLKMSV_
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from collections import Counter
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.models import Model
from tensorflow.keras.layers import LSTM, Dense, Input,Dropout
from keras.layers import Bidirectional



data= pd.read_csv('synthetic_stock_data.csv')

data.head()

from transformers import BertTokenizer, BertForSequenceClassification

finbert = BertForSequenceClassification.from_pretrained('yiyanghkust/finbert-tone',num_labels=3)
tokenizer = BertTokenizer.from_pretrained('yiyanghkust/finbert-tone')

labels = {0:'neutral', 1:'positive',2:'negative'}
X=data['News'].to_list()
sent_val = list()
for x in X:
    inputs = tokenizer(x, return_tensors="pt", padding=True)
    outputs = finbert(**inputs)[0]

    val = labels[np.argmax(outputs.detach().numpy())]
    sent_val.append(val)

counts = Counter(sent_val)
print(counts)

data['Sentiment']=sent_val

data.head()

label_encoder = LabelEncoder()
data['Sentiment'] = label_encoder.fit_transform(data['Sentiment'])

# 0__negative 1__neutral  2__positive

data['Sentiment'].value_counts()

data1=data[['Sentiment','Open','Close','Volume']]

data1

X = np.array(data1[['Sentiment', 'Open', 'Close', 'Volume']])
y = np.array(data1['Close'])



def split_sequence(sequence, n_steps):
    X, y = [], []
    for i in range(len(sequence)):
        end_ix = i + n_steps
        if end_ix > len(sequence) - 1:
            break
        seq_x, seq_y = sequence[i:end_ix, :], sequence[end_ix, 2]  # Predicting 'Close' only
        X.append(seq_x)
        y.append(seq_y)
    return np.array(X), np.array(y)

n_steps=5
X_seq, y_seq = split_sequence(X, n_steps)



n_train=1000
X_train, X_test, y_train, y_test =  X_seq[:n_train], X_seq[n_train:],y_seq[:n_train], y_seq[n_train:]

scaler = MinMaxScaler()
scaler.fit(X_train.reshape(-1, X_train.shape[-1]))
X_train_normalized = scaler.transform(X_train.reshape(-1, X_train.shape[-1])).reshape(X_train.shape)
X_test_normalized = scaler.transform(X_test.reshape(-1, X_test.shape[-1])).reshape(X_test.shape)

scaler_y = MinMaxScaler()
y_train_normalized = scaler_y.fit_transform(y_train.reshape(-1, 1)).reshape(-1)
y_test_normalized = scaler_y.transform(y_test.reshape(-1, 1)).reshape(-1)

model = Sequential()
model.add(LSTM(units=50, activation='relu',input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mse')

model.fit(X_train_normalized, y_train_normalized, epochs=46, batch_size=32, verbose=1)

y_pred_normalized = model.predict(X_test_normalized).flatten()

# Inverse transform predictions to original scale
y_pred = scaler_y.inverse_transform(y_pred_normalized.reshape(-1, 1)).flatten()

# Plotting original vs predicted time series
plt.figure(figsize=(14, 7))
plt.plot(y_test, label='Original Close Prices')
plt.plot(y_pred, label='Predicted Close Prices', linestyle='--')
plt.title('Original vs Predicted Close Prices')
plt.xlabel('Time')
plt.ylabel('Close Price')
plt.legend()
plt.grid(True)
plt.show()

np.mean(np.abs(y_test-y_pred))

model1 = Sequential()
model1.add(Bidirectional(LSTM(units=50, activation='relu'), input_shape=(X_train.shape[1], X_train.shape[2])))
model1.add(Dense(1))
model1.compile(optimizer='adam', loss='mse')
model1.fit(X_train_normalized, y_train, epochs=46, batch_size=32, verbose=1)

y_pred = model1.predict(X_test_normalized)

# Plotting original vs predicted time series
plt.figure(figsize=(14, 7))
plt.plot(y_test, label='Original Close Prices')
plt.plot(y_pred, label='Predicted Close Prices', linestyle='--')
plt.title('Original vs Predicted Close Prices')
plt.xlabel('Time')
plt.ylabel('Close Price')
plt.legend()
plt.grid(True)
plt.show()

np.mean(np.abs(y_test-y_pred))

def split_sequence_new(sequence, n_steps):
    X, y = [], []
    for i in range(len(sequence)):
        end_ix = i + n_steps
        if end_ix > len(sequence) - 1:
            break
        seq_x, seq_y = sequence[i:end_ix, :], sequence[end_ix, 1]  # Predicting 'Close' only
        X.append(seq_x)
        y.append(seq_y)
    return np.array(X), np.array(y)

X1 = np.array(data1[['Open', 'Close', 'Volume']])
y = np.array(data1['Close'])
n_steps=5
X1_seq, y1_seq = split_sequence_new(X1, n_steps)

n_train=1000
X_train, X_test, y_train, y_test =  X1_seq[:n_train], X1_seq[n_train:],y1_seq[:n_train], y1_seq[n_train:]

scaler = MinMaxScaler()
scaler.fit(X_train.reshape(-1, X_train.shape[-1]))
X_train_normalized = scaler.transform(X_train.reshape(-1, X_train.shape[-1])).reshape(X_train.shape)
X_test_normalized = scaler.transform(X_test.reshape(-1, X_test.shape[-1])).reshape(X_test.shape)

model = Sequential()
model.add(LSTM(units=50, activation='relu' ,input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dense(1))

model.compile(optimizer='adam', loss='mse')

model.fit(X_train_normalized, y_train, epochs=46, batch_size=32, verbose=1)

y_pred = model.predict(X_test_normalized)

# Plotting original vs predicted time series
plt.figure(figsize=(14, 7))
plt.plot(y_test, label='Original Close Prices')
plt.plot(y_pred, label='Predicted Close Prices', linestyle='--')
plt.title('Original vs Predicted Close Prices')
plt.xlabel('Time')
plt.ylabel('Close Price')
plt.legend()
plt.grid(True)
plt.show()

np.mean(np.abs(y_test-y_pred))



def split_sequence_2(sequence, n_steps):
    X, y_open,y_close = [], [],[]
    for i in range(len(sequence)):
        end_ix = i + n_steps
        if end_ix > len(sequence) - 1:
            break
        seq_x, seq_y_open,seq_y_close = sequence[i:end_ix, :], sequence[end_ix, 1],sequence[end_ix,2]
        X.append(seq_x)
        y_open.append(seq_y_open)
        y_close.append(seq_y_close)
    return np.array(X), np.array(y_open),np.array(y_close)

X = np.array(data1[['Sentiment', 'Open', 'Close', 'Volume']])
y = np.array(data1[['Open','Close']])

n_steps=5
X_seq, y_open_seq,y_close_seq = split_sequence_2(X, n_steps)

n_train = 1000
X_train, X_test = X_seq[:n_train], X_seq[n_train:]
y_open_train, y_open_test = y_open_seq[:n_train], y_open_seq[n_train:]
y_close_train, y_close_test = y_close_seq[:n_train], y_close_seq[n_train:]

# Normalize the data
scaler_X = MinMaxScaler()
scaler_y_open = MinMaxScaler()
scaler_y_close = MinMaxScaler()

# Fit and transform the X data
X_train_normalized = scaler_X.fit_transform(X_train.reshape(-1, X_train.shape[-1])).reshape(X_train.shape)
X_test_normalized = scaler_X.transform(X_test.reshape(-1, X_test.shape[-1])).reshape(X_test.shape)

# Fit and transform the y data
y_open_train_normalized = scaler_y_open.fit_transform(y_open_train.reshape(-1, 1)).flatten()
y_open_test_normalized = scaler_y_open.transform(y_open_test.reshape(-1, 1)).flatten()
y_close_train_normalized = scaler_y_close.fit_transform(y_close_train.reshape(-1, 1)).flatten()
y_close_test_normalized = scaler_y_close.transform(y_close_test.reshape(-1, 1)).flatten()

input_layer = Input(shape=(X_train.shape[1], X_train.shape[2]))
lstm_layer1 = LSTM(50, activation='relu')(input_layer)
output_open = Dense(1, name='open_output')(lstm_layer1)
output_close = Dense(1, name='close_output')(lstm_layer1)

model = Model(inputs=input_layer, outputs=[output_open, output_close])
model.compile(optimizer='adam', loss='mse')

model.fit(X_train_normalized, [y_open_train_normalized, y_close_train_normalized], epochs=50, batch_size=30, verbose=1)
# Predictions
y_open_pred_normalized, y_close_pred_normalized = model.predict(X_test_normalized)

# Inverse transform predictions to original scale
y_open_pred = scaler_y_open.inverse_transform(y_open_pred_normalized)
y_close_pred = scaler_y_close.inverse_transform(y_close_pred_normalized)

plt.figure(figsize=(14, 14))

# Subplot for Open Prices
plt.subplot(2, 1, 1)
plt.plot(y_open_test, label='Original Open Prices')
plt.plot(y_open_pred, label='Predicted Open Prices', linestyle='--')
plt.title('Original vs Predicted Open Prices')
plt.xlabel('Time')
plt.ylabel('Open Price')
plt.legend()
plt.grid(True)

# Subplot for Close Prices
plt.subplot(2, 1, 2)
plt.plot(y_close_test, label='Original Close Prices')
plt.plot(y_close_pred, label='Predicted Close Prices', linestyle='--')
plt.title('Original vs Predicted Close Prices')
plt.xlabel('Time')
plt.ylabel('Close Price')
plt.legend()
plt.grid(True)

plt.tight_layout()
plt.show()

np.mean(np.abs(y_open_test-y_open_pred))

np.mean(np.abs(y_close_test-y_close_pred))

